<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Peng Yan</title>
    <link>https://ryanfakir.github.io/index.xml</link>
    <description>Recent content on Peng Yan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Sat, 24 Dec 2016 18:37:06 -0500</lastBuildDate>
    <atom:link href="https://ryanfakir.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Hand Dirty with Golang</title>
      <link>https://ryanfakir.github.io/hand-dirty-with-golang/</link>
      <pubDate>Sat, 24 Dec 2016 18:37:06 -0500</pubDate>
      
      <guid>https://ryanfakir.github.io/hand-dirty-with-golang/</guid>
      <description>

&lt;h4 id=&#34;task-web-crawler-with-go&#34;&gt;Task: web crawler with go&lt;/h4&gt;

&lt;p&gt;main.go&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;type Links struct {
	Level int
	Link  string
}

var tokens = make(chan struct{}, 1)

func main() {
	flag.Parse()
	// depth := fvalue.Value
	c := utility.New()
	c.ParsingPath = &amp;quot;https://ryanfakir.github.io&amp;quot;
	linkList := make(chan Links)
	depth := 3
	var i int
	i++
	go func() {
		linkList &amp;lt;- Links{1, c.ParsingPath}
	}()
	m := make(map[string]bool)
	for ; i &amp;gt; 0; i-- {
		fmt.Printf(&amp;quot;i = %+v\n&amp;quot;, i)
		link := &amp;lt;-linkList
		//fmt.Printf(&amp;quot;-------------- = %+v\n&amp;quot;, &amp;quot;--------------&amp;quot;)
		//fmt.Printf(&amp;quot; runtime.NumGoroutine()= %+v\n&amp;quot;, runtime.NumGoroutine())
		// fmt.Printf(&amp;quot;m = %+v\n&amp;quot;, m)
		if !m[link.Link] &amp;amp;&amp;amp; link.Level &amp;lt; depth {
			m[link.Link] = true
			i++
			tokens &amp;lt;- struct{}{}
			go func(link Links) {
				// fmt.Printf(&amp;quot;link = %+v\n&amp;quot;, link)
				res := c.Parser(link.Link)
				&amp;lt;-tokens
				for _, v := range res {
					linkList &amp;lt;- Links{link.Level + 1, v}
				}
			}(link)
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;func main() {
	start := time.Now()
	c := utility.New()
	c.ParsingPath = &amp;quot;https://ryanfakir.github.io&amp;quot;
	linkList := make(chan Links)
	out := make(chan Links)
	depth := 3
	go func() {
		// start first link
		linkList &amp;lt;- Links{1, c.ParsingPath}
		tokens &amp;lt;- struct{}{}
	}()
	var res []Links
	for i := 0; i &amp;lt; 2; i++ {
		go func() {
			for v := range linkList {
				fmt.Printf(&amp;quot; runtime.NumGoroutine()= %+v\n&amp;quot;, runtime.NumGoroutine())
				if v.Level &amp;gt;= depth {
					continue
				}
				select {
				case &amp;lt;-tokens:
					// append untouch urls from res
					var items []Links
					for _, unTouchedLinks := range res {
						for _, url := range c.Parser(unTouchedLinks.Link) {
							items = append(items, Links{unTouchedLinks.Level + 1, url})
						}
					}
					for _, url := range c.Parser(v.Link) {
						items = append(items, Links{v.Level + 1, url})
					}
					res = append(res, items...)
					// go func(v Links, res []string) {
					for _, item := range res {
						out &amp;lt;- item
					}
				default:
					res = append(res, v)
				}
				//}(v, res)
			}
		}()
	}

	m := make(map[string]bool)
	var i int
	for link := range out {
		if !m[link.Link] &amp;amp;&amp;amp; link.Level &amp;lt;= depth {
			i++
			fmt.Printf(&amp;quot;time.Since(start) = %+v\n&amp;quot;, time.Since(start))
			fmt.Printf(&amp;quot;i = %+v\n&amp;quot;, i)
			m[link.Link] = true
			go func() {
				tokens &amp;lt;- struct{}{}
				linkList &amp;lt;- link
			}()

		}
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;type Links struct {
	Level int
	Link  string
}

var tokens = make(chan struct{}, 1)

func main() {
	start := time.Now()
	c := utility.New()
	c.ParsingPath = &amp;quot;https://ryanfakir.github.io&amp;quot;
	linkList := make(chan Links)
	out := make(chan Links)
	depth := 3
	wg := &amp;amp;sync.WaitGroup{}
	go func() {
		linkList &amp;lt;- Links{1, c.ParsingPath}
		wg.Add(1)
	}()
	for i := 0; i &amp;lt; 2; i++ {
		go func() {
			for v := range linkList {
				fmt.Printf(&amp;quot; runtime.NumGoroutine()= %+v\n&amp;quot;, runtime.NumGoroutine())
				if v.Level &amp;gt;= depth {
					continue
				}
				res := c.Parser(v.Link)
				go func(v Links, res []string) {
					for _, item := range res {
						wg.Add(1)
						out &amp;lt;- Links{v.Level + 1, item}
					}
				}(v, res)
			}
		}()
	}

	m := make(map[string]bool)
	var i int
	for link := range out {
		if !m[link.Link] &amp;amp;&amp;amp; link.Level &amp;lt;= depth {
			wg.Done()
			fmt.Printf(&amp;quot;time.Since(start) = %+v\n&amp;quot;, time.Since(start))
			// How many link been processed
			i++
			fmt.Printf(&amp;quot;i = %+v\n&amp;quot;, i)
			m[link.Link] = true
			linkList &amp;lt;- link
		}
	}
	// This won&#39;t work because out channel never end, so it dead lock, even though all links within depth finished processing
	wg.Wait()
	fmt.Println(&amp;quot;done&amp;quot;)
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;utility.go&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;var fvalue = DepthFlag{3}

type Client struct {
	Url         *url.URL
	Fvalue      *DepthFlag
	ParsingPath string
}

func New() *Client {
	return &amp;amp;Client{}
}
func (c *Client) Parser(url string) []string {
	resp, err := http.Get(url)
	if err != nil {
		fmt.Errorf(&amp;quot;http get %s with error %v&amp;quot;, url, err)
		return nil
	}
	if resp.StatusCode != http.StatusOK {
		fmt.Errorf(&amp;quot;http get status not OK: %s with %v&amp;quot;, url, err)
		return nil
	}
	defer resp.Body.Close()
	doc, err := html.Parse(resp.Body)
	if err != nil {
		fmt.Errorf(&amp;quot;parse problem %s with error %v&amp;quot;, url, err)
		return nil
	}
	c.Url = resp.Request.URL
	pre := c.findLink
	res := removeDuplicate(forEachNode(doc, pre, nil), url)
	return res
}

func removeDuplicate(elements []string, url string) (res []string) {
	m := make(map[string]bool)
	for _, v := range elements {
		v = strings.TrimSuffix(v, &amp;quot;/&amp;quot;)
		m[v] = true
	}
	for k, _ := range m {
		if url != k {
			res = append(res, k)
		}
	}
	return
}

type DepthFlag struct {
	Value int
}

func (d *DepthFlag) String() string {
	return strconv.Itoa(d.Value)
}
func (d *DepthFlag) Set(s string) error {
	var value int
	_, err := fmt.Sscanf(s, &amp;quot;%d&amp;quot;, &amp;amp;value)
	if err != nil {
		fmt.Errorf(&amp;quot;problem with flag %s&amp;quot;, s)
		return err
	}
	d.Value = value
	return nil
}
func init() {
	flag.Var(&amp;amp;fvalue, &amp;quot;depth&amp;quot;, &amp;quot;Depth Parameter&amp;quot;)
}

func (c *Client) findLink(n *html.Node) (res []string) {
	if n.Type == html.ElementNode &amp;amp;&amp;amp; n.Data == &amp;quot;a&amp;quot; {
		for _, v := range n.Attr {
			if v.Key != &amp;quot;href&amp;quot; {
				continue
			}
			temp, err := c.Url.Parse(v.Val)
			if err != nil {
				continue
			}
			res = append(res, temp.String())
		}
	}
	return
}
func forEachNode(n *html.Node, pre, post func(n *html.Node) []string) (res []string) {
	if pre != nil {
		res = append(res, pre(n)...)
	}
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		res = append(res, forEachNode(c, pre, post)...)
	}
	if post != nil {
		res = append(res, post(n)...)
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Angular Checkbox</title>
      <link>https://ryanfakir.github.io/angular-checkbox/</link>
      <pubDate>Sun, 18 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ryanfakir.github.io/angular-checkbox/</guid>
      <description>

&lt;p&gt;If we need make some directives like widgets — meaning drag and use, how to we want to design it, let’s practice from ground.&lt;br /&gt;
Right now we have&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;input id=&amp;quot;action&amp;quot; type=&amp;quot;checkbox&amp;quot;&amp;gt;  
&amp;lt;label for=&amp;quot;action&amp;quot;&amp;gt;Action will triggerlabel&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;case-1&#34;&gt;Case 1&lt;/h3&gt;

&lt;p&gt;When I check the checkbox, I want to fire event which will call backend service.&lt;br /&gt;
You may want to code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;@Directive({
  selector: &#39;input[action]&#39;,
  events: [&#39;callBackend&#39;],
  host: {
    &#39;(change)&#39;: &#39;emitOut()&#39;
  }

})
export class CheckboxTriggerActionDirective {
  callBackend: EventEmitter&amp;lt;any&amp;gt; = new EventEmitter();

  emitOut() {
    this.callBackend.emit(&#39;checkbox emit data out side&#39;);
  }
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And you put directive like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt; ||         ||  
 \/         \/  
&amp;lt;input id=&amp;quot;action&amp;quot; type=&amp;quot;checkbox&amp;quot; action (callBackend)=&amp;quot;callbackend($event)&amp;quot;&amp;gt;  
&amp;lt;label for=&amp;quot;action&amp;quot;&amp;gt;Action will triggerlabel&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s talk basic angular2 important knowledge real quick:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Angular2 have two main decorators (@Directive and @Component), or you can understand as Annotation if you are Java Guy, which put the metadata(additional informative data) above class definition, to let Angular2 compiler to know when and where to apply the functionality you are defined.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;You can briefly take @Component = @Directive + Template.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;In Angular2 Data flow is one way, always from Component class instance member(Ex. callBackend is instance member of class CheckboxTriggerActionDirective) to template.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;In our example,&lt;br /&gt;
[selector] will ask angular to parse template to find tag input which have attribute “action”.&lt;br /&gt;
[events] which tell angular this directive will have customize-event which in our application somewhere it can be listen to or subscribe to.&lt;br /&gt;
[host] means the DOM element which hosts our directive, in our case is input, it means when we hear some change events happened from host element, our directive will call function emitOut().&lt;br /&gt;
Remember (xxx) means output from DOM element, it can be built-in event or customize function call. In emitOut() our customized event will shout out, our application can listen to the value or message it sends(this message can be object or internal usefully information which can let whole world know you LOL), and do some action(EX. call backend service).&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;data-flow&#34;&gt;Data flow:&lt;/h3&gt;

&lt;p&gt;checkbox status changed ——&amp;gt; call emitOut() ——&amp;gt; callBackend emit message ——&amp;gt; observer or listener will do operations&lt;/p&gt;

&lt;p&gt;Next we will make our checkbox more generic and reusable.&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
  </channel>
</rss>